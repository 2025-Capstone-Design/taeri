<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ê³µí•­ ì‹¤ë‚´ GPS ë° URL ì—°ë™ ë‚´ë¹„ê²Œì´í„°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background:#f4f7f9; margin:0; padding:1rem; }
        /* ìº”ë²„ìŠ¤ê°€ ë¶€ëª¨ í¬ê¸°ì— ë§ì¶° ë°˜ì‘í•˜ë„ë¡ max-width ëŒ€ì‹  width: 100% ì‚¬ìš© */
        #map-canvas { width:100%; height:520px; background:#fff; border:1px solid #ddd; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.1); }
        .card { background:white; padding:1.5rem; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.08); margin-bottom:1rem; }
        /* ë‚´ë¹„ê²Œì´ì…˜ ë°” ì´ˆê¸°ì—ëŠ” ìˆ¨ê²¨ì ¸ ìˆì–´ì•¼ í•¨ */
        #nav-bar { position:fixed; bottom:0; left:0; right:0; background:#1e40af; color:white; padding:1rem; border-top-left-radius:16px; border-top-right-radius:16px; box-shadow:0 -4px 20px rgba(0,0,0,0.3); transform:translateY(100%); transition:transform 0.3s ease-out; z-index:1000; }
        #nav-bar.active { transform:translateY(0); }
        .status-ok { background:#d1fae5; color:#065f46; border:1px solid #34d399; }
        .status-err { background:#fee2e2; color:#991b1b; border:1px solid #f87171; }
    </style>

</head>
<body>

<button id="permissionBtn" style="position:fixed; top:10px; right:10px; z-index:9999; padding:10px;">
    ë‚˜ì¹¨ë°˜ ì¼œê¸°
</button>

<div class="max-w-4xl mx-auto pb-32">

    <h1 class="text-3xl font-bold text-gray-800 mb-6">âœˆï¸ ê³µí•­ ì‹¤ë‚´ GPS ë‚´ë¹„ê²Œì´ì…˜</h1>

    <div class="card">
        <div id="status" class="p-3 rounded-lg status-err text-sm font-medium mb-4">
            ì¤€ë¹„ ì¤‘: ì¶œë°œì§€ì™€ ë„ì°©ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
            <div>
                <label class="block text-sm font-medium mb-1">
                    ì¶œë°œ êµ¬ì—­
                    <span id="qr-hint" class="text-xs text-green-600 font-bold"></span>
                </label>
                <select id="start" class="w-full p-3 border rounded-lg"></select>
            </div>
            <div>
                <label class="block text-sm font-medium mb-1">
                    ë„ì°© êµ¬ì—­ 
                </label>
                <select id="end" class="w-full p-3 border rounded-lg"></select>
            </div>
            <div>
                <button id="find" class="w-full bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700">
                    ê²½ë¡œ ì°¾ê¸°
                </button>
            </div>
        </div>
    </div>

    <div class="card">
        <h2 class="text-xl font-bold mb-4">ì§€ë„ (ì¤Œ/ì´ë™ ê°€ëŠ¥)</h2>
        <canvas id="map-canvas"></canvas>
        <div id="info" class="mt-4 text-gray-600"></div>
    </div>

</div>

<!-- ë‚´ë¹„ê²Œì´ì…˜ ë°” -->
<div id="nav-bar">
    <div class="flex justify-between items-center">
        <div class="flex items-center gap-4">
            <div id="icon"><i data-lucide="compass" class="w-10 h-10"></i></div>
            <div>
                <div id="instruction" class="text-xl font-bold">ëŒ€ê¸° ì¤‘</div>
                <div id="distance" class="text-sm opacity-90">ë‚¨ì€ ì´ ê²½ë¡œ: -</div>
            </div>
        </div>
        <button id="nav-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold px-6 py-3 rounded-full" disabled>
            ë‚´ë¹„ ì‹œì‘
        </button>
    </div>
</div>

<script>
// ====================================================================
// ì „ì—­ ë³€ìˆ˜ ë° PDR/í•„í„° ì •ì˜
// ====================================================================
let canvas, ctx, route = null, watching = false, watchId = null;
let userPos = { lat: 0, lon: 0, heading: 0, acc: 0 }; // ì‚¬ìš©ì ìœ„ì¹˜/ë°©í–¥
let offset = {lat:0, lon:0};
let scale = 1, tx = 0, ty = 0; // ì¤Œ/íŒ¬ ë³€ìˆ˜

// --- í•„í„° ë° PDR ë¡œì§ ë³€ìˆ˜ ---
let smoothedHeading = 0;
const SMOOTH_FACTOR = 0.15; // ë¶€ë“œëŸ¬ì›€ ì •ë„ ì¡°ì ˆ (0.05 ~ 0.3)
let lastAccelZ = 0;
let isStepping = false;
const STEP_THRESHOLD = 1.2; // ê±·ê¸° ê°ì§€ ì„ê³„ê°’ (m/s^2)
const STEP_LENGTH_LAT = 0.000020; // ğŸ‘ˆ í•œ ê±¸ìŒë‹¹ ì´ë™í•  ìœ„ë„ ë³€í™”ëŸ‰ (ì¦í­ëœ ê°’)

// 1. Heading í•„í„°ë§ í•¨ìˆ˜ (360ë„ ì í”„ ë°©ì§€ ê¸°ëŠ¥ í¬í•¨)
function applyFilter(newRaw, oldSmooth) {
    let diff = newRaw - oldSmooth;
    if (diff > 180) diff -= 360;
    if (diff < -180) diff += 360;
    return oldSmooth + (diff * SMOOTH_FACTOR);
}

// PDR (ì¶”ì¸¡ í•­ë²•) - ê±¸ìŒ ê°ì§€ ë° ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
const handleMotion = function(event) {
    if (!watching || !userPos) return;

    const accZ = event.accelerationIncludingGravity.z;
    const accelDiff = accZ - lastAccelZ;

    // ê±¸ìŒ ê°ì§€
    if (accelDiff > STEP_THRESHOLD && !isStepping) {
        isStepping = true;
        
        // ë°©í–¥ ê³„ì‚° (í•„í„°ë§ëœ ë°©í–¥ ì‚¬ìš©)
        const headingRad = smoothedHeading * (Math.PI / 180);

        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (PDR ë²¡í„° ì´ë™)
        userPos.lat += Math.cos(headingRad) * STEP_LENGTH_LAT;
        userPos.lon += Math.sin(headingRad) * STEP_LENGTH_LAT;
        
        draw(); 
        updateStatus("ok", "ğŸš¶ PDR í™œì„±: ê±¸ìŒ ê°ì§€ ë° ìœ„ì¹˜ ì¶”ì  ì¤‘...");
    } else if (accelDiff < -STEP_THRESHOLD) {
        isStepping = false;
    }

    lastAccelZ = accZ;
};

// ë‚˜ì¹¨ë°˜ ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ í•¨ìˆ˜ (RAW heading ì—…ë°ì´íŠ¸)
const sensorHandler = function(event) {
    let heading = null;
    if (event.webkitCompassHeading) { // iOS
        heading = event.webkitCompassHeading;
    } else if (event.alpha) { // Android (ìŠ¤í¬ë¦° íšŒì „ ë³´ì • í¬í•¨)
        let screenAngle = (window.screen.orientation.angle || 0);
        heading = 360 - ((event.alpha + screenAngle) % 360);
    }
    if (heading !== null) {
        userPos.heading = heading;
    }
};


// URL íŒŒë¼ë¯¸í„°ë¥¼ ì½ëŠ” í•¨ìˆ˜
function getUrlParam(name) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(name);
}

// DOM ë¡œë“œ í›„ ì´ˆê¸°í™”
window.onload = function() {
    canvas = document.getElementById('map-canvas');
    ctx = canvas.getContext('2d');
    
    // ì…€ë ‰íŠ¸ ì±„ìš°ê¸°
    const startSel = document.getElementById('start');
    const endSel = document.getElementById('end');
    Object.keys(AREAS).forEach(k => {
        const opt = `<option value="${k}">${k} - ${AREAS[k].name}</option>`;
        startSel.insertAdjacentHTML('beforeend', opt);
        endSel.insertAdjacentHTML('beforeend', opt);
    });
    startSel.value = "A"; // ê¸°ë³¸ê°’ ì„¤ì •
    endSel.value = "I";
    
    // URL íŒŒë¼ë¯¸í„° ì²˜ë¦¬ ë¡œì§
    const initialStart = getUrlParam('area');
    let isValidInitialStart = false;
    
    if (initialStart) {
        const startId = initialStart.toUpperCase().trim();
        if (AREAS[startId]) {
            startSel.value = startId;
            document.getElementById('qr-hint').textContent = `(URL: ${startId}ë¡œ ì¶œë°œì§€ ì„¤ì •ë¨)`;
            updateStatus("ok", `URL íŒŒë¼ë¯¸í„°: ì¶œë°œì§€ê°€ ${AREAS[startId].name}ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ë„ì°©ì§€ë¥¼ ì„ íƒí•˜ê³  ê²½ë¡œ ì°¾ê¸°ë¥¼ ëˆ„ë¥´ì„¸ìš”.`);
            isValidInitialStart = true;
        }
    }

    // ì´ë²¤íŠ¸
    document.getElementById('find').onclick = findRoute;
    document.getElementById('nav-btn').onclick = toggleNav;
    // ì•„ì´í° ê¶Œí•œ ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ (HTML bodyì˜ permissionBtnê³¼ ì—°ê²°)
    const btn = document.getElementById("permissionBtn");
    btn.addEventListener("click", () => {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        alert("ë‚˜ì¹¨ë°˜ ê¶Œí•œ í—ˆìš©ë¨!");
                        document.getElementById("permissionBtn").style.display = 'none'; 
                    } else {
                        alert("ê¶Œí•œ ê±°ë¶€ë¨.");
                    }
                })
                .catch(console.error);
        } else {
            alert("ì´ ê¸°ê¸°ëŠ” ê¶Œí•œ ìš”ì²­ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤.");
        }
    });

    setupCanvasEvents();
    resizeCanvas();
    draw();
    lucide.createIcons();
    
    if (!isValidInitialStart) {
        updateStatus("err", "ì¤€ë¹„ ì¤‘: ì¶œë°œì§€ì™€ ë„ì°©ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.");
    }
};

function resizeCanvas() {
    const w = canvas.parentElement.clientWidth;
    canvas.width = w > 900 ? 900 : w; 
    canvas.height = canvas.width * 0.6;
    if (canvas.height < 400) canvas.height = 400;
    draw();
}
window.addEventListener('resize', resizeCanvas);

// -------------------------
// ë‚´ë¹„ê²Œì´ì…˜ ë° ê²½ë¡œ ë¡œì§
// -------------------------

function findRoute() {
    if(watching) stopNav(); // ê²½ë¡œ ì¬íƒìƒ‰ ì‹œ ë‚´ë¹„ ì •ì§€

    const start = document.getElementById('start').value;
    const end = document.getElementById('end').value;
    
    if (start === end) {
        updateStatus("err", "ì¶œë°œì§€ì™€ ë„ì°©ì§€ê°€ ê°™ìŠµë‹ˆë‹¤!");
        return; 
    }

    route = dijkstra(start, end);
    if (!route) {
        updateStatus("err", "ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ìš”");
        document.getElementById('nav-btn').disabled = true;
        document.getElementById('nav-bar').classList.remove('active');
        return;
    }
    
    route.currentStep = 0; // ê²½ë¡œ ì°¾ì„ ë•Œ ë‹¨ê³„ ì´ˆê¸°í™”

    document.getElementById('info').innerHTML = 
        `<strong>ì´ ê²½ë¡œ ê¸¸ì´: ${route.dist.toFixed(0)}m | ì˜ˆìƒ ì†Œìš” ì‹œê°„ ì•½ ${Math.ceil(route.dist/80)}ë¶„</strong>`;

    document.getElementById('nav-btn').disabled = false;
    document.getElementById('nav-btn').textContent = "ë‚´ë¹„ ì‹œì‘";
    document.getElementById('nav-btn').classList.replace('bg-red-500','bg-green-500');
    document.getElementById('nav-bar').classList.add('active');
    
    updateNavUI(route.steps[0].instruction, route.dist);
    draw();
    updateStatus("ok", "ê²½ë¡œ ê³„ì‚° ì™„ë£Œ! 'ë‚´ë¹„ ì‹œì‘'ì„ ëˆ„ë¥´ì„¸ìš”.");
}

function toggleNav() {
    if (!route) return;
    
    if (document.getElementById('nav-btn').textContent === "ì¬ì„¤ì •") {
        resetApp(); 
        return;
    }

    if (watching) {
        stopNav();
    } else {
        startNav();
    }
}

// startNav í•¨ìˆ˜ (PDR ë° GPS ì„¼ì„œ ì´ˆê¸°í™”)
function startNav() {
    if (!navigator.geolocation) {
        updateStatus("err", "GPSë¥¼ ì§€ì›í•˜ì§€ ì•Šì•„ìš”");
        return;
    }
    
    watching = true;
    document.getElementById('nav-btn').textContent = "ì •ì§€";
    document.getElementById('nav-btn').classList.replace('bg-green-500','bg-red-500');
    updateStatus("ok", "GPS ì—°ê²° ì¤‘...");
    
    // 1. ì„¼ì„œ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (PDR ë° ë°©í–¥)
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(r => {
            if (r === 'granted') {
                window.addEventListener('deviceorientation', sensorHandler);
                window.addEventListener('devicemotion', handleMotion); // PDR í™œì„±í™”
            } else {
                 updateStatus("err", "ë‚˜ì¹¨ë°˜ ê¶Œí•œì´ ê±°ë¶€ë˜ì–´ ë°©í–¥ ì¶”ì ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.");
            }
        }).catch(e => console.error("Orientation permission denied:", e));
    } else {
        window.addEventListener('deviceorientation', sensorHandler);
        window.addEventListener('devicemotion', handleMotion); // PDR í™œì„±í™”
    }
    
    // 2. GPS ì‹œì‘ (ì˜¤í”„ì…‹ ê³„ì‚° ë° ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •)
    navigator.geolocation.getCurrentPosition(pos => {
        const realLat = pos.coords.latitude;
        const realLon = pos.coords.longitude;
        const startArea = AREAS[route.path[0]];
        offset.lat = realLat - startArea.lat;
        offset.lon = realLon - startArea.lon;
        updateStatus("ok", "ì˜¤í”„ì…‹ ì„¤ì • ì™„ë£Œ! ì´ë™ ì‹œì‘í•˜ì„¸ìš”");
        onLocation(pos);
    }, onError, { enableHighAccuracy: true, timeout: 5000 });

    watchId = navigator.geolocation.watchPosition(onLocation, onError, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 5000
    });
}

function stopNav() {
    watching = false;
    if (watchId) navigator.geolocation.clearWatch(watchId);
    
    // PDR ë° ë°©í–¥ ì„¼ì„œ ëª¨ë‘ ì œê±°
    window.removeEventListener('deviceorientation', sensorHandler); 
    window.removeEventListener('devicemotion', handleMotion); 
    
    document.getElementById('nav-btn').textContent = "ì¬ê°œ";
    document.getElementById('nav-btn').classList.replace('bg-red-500','bg-yellow-500');
    updateStatus("err", "ë‚´ë¹„ê²Œì´ì…˜ ì¼ì‹œ ì •ì§€ë¨");
}

function onLocation(pos) {
    if (!watching || !route) return;

    // GPS ì‹ í˜¸ê°€ ì¡í ë•Œë§Œ ìœ„ì¹˜ë¥¼ ë³´ì •í•©ë‹ˆë‹¤. (PDRì´ ì›€ì§ì„ì„ ë‹´ë‹¹)
    const realLat = pos.coords.latitude;
    const realLon = pos.coords.longitude;
    
    // ì˜¤í”„ì…‹ ì ìš©í•´ì„œ ì§€ë„ ì¢Œí‘œê³„ë¡œ ë³€í™˜ (PDRì´ í™œì„±í™”ë˜ë©´ ì´ ì½”ë“œëŠ” ì •ì§€ëœ GPSë¥¼ ë³´ì •í•˜ëŠ” ì—­í• ë§Œ í•¨)
    userPos.lat = realLat - offset.lat;
    userPos.lon = realLon - offset.lon;
    userPos.acc = pos.coords.accuracy;

    updateStatus("ok", `GPS ì¶”ì  ì¤‘ | ì •í™•ë„ ${pos.coords.accuracy.toFixed(1)}m`);

    const step = route.steps[route.currentStep];
    const target = AREAS[step.to];
    
    // 1. í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë‹¤ìŒ ë…¸ë“œê¹Œì§€ì˜ ì§ì„  ê±°ë¦¬ (ë‹¨ê³„ í†µê³¼ ì¡°ê±´)
    const distToNextNode = haversine(userPos.lat, userPos.lon, target.lat, target.lon); 
    
    // 2. ì´ ë‚¨ì€ ê²½ë¡œ ê±°ë¦¬ ê³„ì‚°
    let currentStepRemaining = Math.min(step.dist, distToNextNode);

    let totalRemainingDist = 0;
    totalRemainingDist += currentStepRemaining; 
    
    for (let i = route.currentStep + 1; i < route.steps.length; i++) {
        totalRemainingDist += route.steps[i].dist;
    }

    // ë‚´ë¹„ê²Œì´ì…˜ UI ì—…ë°ì´íŠ¸ (ì´ ë‚¨ì€ ê±°ë¦¬ ì‚¬ìš©)
    updateNavUI(step.instruction, totalRemainingDist);
    
    // ë‹¨ê³„ í†µê³¼ ì²´í¬ (ì§ì„  ê±°ë¦¬ ì‚¬ìš©)
    if (distToNextNode < 30) { // 30m ì´ë‚´ ì§„ì… ì‹œ ë‹¤ìŒ ë‹¨ê³„ë¡œ (PDR ê°ì§€ë³´ë‹¤ GPSê°€ ìš°ì„¸í•  ê²½ìš°)
        route.currentStep++;
        if (route.currentStep >= route.steps.length) {
            arrive();
        } else {
            const nextStep = route.steps[route.currentStep];
            const nextTarget = AREAS[nextStep.to];
            const nextDistToNextNode = haversine(userPos.lat, userPos.lon, nextTarget.lat, nextTarget.lon); 
            
            let nextStepRemaining = Math.min(nextStep.dist, nextDistToNextNode);
            let newTotalRemainingDist = nextStepRemaining;
            for (let i = route.currentStep + 1; i < route.steps.length; i++) {
                newTotalRemainingDist += route.steps[i].dist;
            }
            updateNavUI(nextStep.instruction, newTotalRemainingDist);
        }
    }

    draw();
}



function onError(e) {
    if (watching) {
        updateStatus("err", "GPS ì˜¤ë¥˜: " + e.message + " (ì‹ í˜¸ ë³µêµ¬ ëŒ€ê¸° ì¤‘)");
    }
}

function arrive() {
    stopNav();
    document.getElementById('instruction').textContent = "ëª©ì ì§€ ë„ì°©! ğŸ¥³";
    document.getElementById('distance').textContent = "ì¶•í•˜í•©ë‹ˆë‹¤! ì´ ê²½ë¡œ 0m ë‚¨ìŒ";
    document.getElementById('icon').innerHTML = `<i data-lucide="map-pin" class="w-10 h-10"></i>`;
    lucide.createIcons();
    
    document.getElementById('nav-btn').textContent = "ì¬ì„¤ì •";
    document.getElementById('nav-btn').classList.replace('bg-yellow-500','bg-blue-600');
    updateStatus("ok", "ëª©ì ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤!");
}

function resetApp() {
    stopNav();
    route = null;
    userPos = null;
    heading = 0;
    offset = {lat:0, lon:0};
    document.getElementById('nav-bar').classList.remove('active');
    document.getElementById('nav-btn').disabled = true;
    document.getElementById('nav-btn').textContent = "ë‚´ë¹„ ì‹œì‘";
    document.getElementById('nav-btn').classList.replace('bg-blue-600','bg-green-500');
    document.getElementById('qr-hint').textContent = '';
    updateNavUI('ëŒ€ê¸° ì¤‘', 0);
    updateStatus("err", "ì¤€ë¹„ ì¤‘: ì¶œë°œì§€ì™€ ë„ì°©ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.");
    draw();
}

function updateNavUI(instruction, totalRemainingDist) {
    document.getElementById('instruction').textContent = instruction;
    document.getElementById('distance').textContent = `ë‚¨ì€ ì´ ê²½ë¡œ: ${totalRemainingDist.toFixed(0)}m`;
    
    if (route && route.currentStep < route.steps.length) {
        const step = route.steps[route.currentStep];
        document.getElementById('icon').innerHTML = `<i data-lucide="${step.icon}" class="w-10 h-10"></i>`;
        lucide.createIcons();
    }
}

// ë‹¤ìµìŠ¤íŠ¸ë¼ (ê²½ë¡œ ê°ì²´ì— distì™€ instruction í¬í•¨í•˜ë„ë¡ ìˆ˜ì •)
function dijkstra(start, end) {
    const graph = {};
    ALL_EDGES.forEach(e => {
        graph[e.from] = graph[e.from] || [];
        graph[e.from].push({ to: e.to, dist: e.dist, instruction: e.instruction, icon: e.icon });
    });

    const dist = {}, prev = {}, q = new Set(Object.keys(AREAS));
    Object.keys(AREAS).forEach(k => dist[k] = Infinity);
    dist[start] = 0;

    while (q.size) {
        let min = null;
        // ê°€ì¥ ê±°ë¦¬ê°€ ì§§ì€ ë…¸ë“œ ì°¾ê¸°
        q.forEach(n => { if (dist[n] < dist[min] || min === null) min = n; });
        if (min === end || dist[min] === Infinity) break;
        q.delete(min);

        graph[min] && graph[min].forEach(edge => {
            const alt = dist[min] + edge.dist;
            if (alt < dist[edge.to]) {
                dist[edge.to] = alt;
                prev[edge.to] = { node: min, edge: edge };
            }
        });
    }

    if (dist[end] === Infinity) return null;

    const pathNodes = [];
    const steps = [];
    let totalDist = dist[end];
    let u = end;
    
    // ê²½ë¡œ ì—­ì¶”ì 
    while (u) { pathNodes.unshift(u); u = prev[u] ? prev[u].node : null; }
    
    // ë‹¨ê³„ ì •ë³´ ì¶”ì¶œ
    for (let i = 0; i < pathNodes.length - 1; i++) {
        const fromNode = pathNodes[i];
        const toNode = pathNodes[i+1];
        
        // prev ê°ì²´ì—ì„œ toNodeë¡œ ì˜¤ëŠ” ë° ì‚¬ìš©ëœ ì—£ì§€ ì •ë³´ë¥¼ ì°¾ì•„ ë‹¨ê³„ì— ì¶”ê°€
        if (prev[toNode] && prev[toNode].node === fromNode) {
            steps.push({
                from: fromNode,
                to: toNode,
                dist: prev[toNode].edge.dist, // ë‹¨ê³„ë³„ ê±°ë¦¬ í¬í•¨
                instruction: prev[toNode].edge.instruction,
                icon: prev[toNode].edge.icon
            });
        }
    }
    
    // ìµœì¢… ë„ì°© ì•„ì´ì½˜ ì„¤ì •
    if (steps.length > 0) {
        steps[steps.length - 1].icon = "map-pin";
        steps[steps.length - 1].instruction = `${AREAS[end].name}ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤.`;
    }

    return {path: pathNodes, steps, dist: totalDist, currentStep: 0};
}

// í•˜ë²„ì‹  ê±°ë¦¬ (ì‚¬ìš©ì ì¢Œí‘œì™€ ë§µ ì¢Œí‘œ ê°„ì˜ ê±°ë¦¬ ì¸¡ì •)
function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dlat = toRad(lat2-lat1);
    const dlon = toRad(lon2-lon1);
    const a = Math.sin(dlat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dlon/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function updateStatus(type, msg) {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.className = "p-3 rounded-lg text-sm font-medium mb-4 " + (type==="ok"?"status-ok":"status-err");
}

// ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // ë§µ ê²½ê³„ ê³„ì‚°
    let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
    Object.values(AREAS).forEach(a => {
        minLat = Math.min(minLat, a.lat); maxLat = Math.max(maxLat, a.lat);
        minLon = Math.min(minLon, a.lon); maxLon = Math.max(maxLon, a.lon);
    });

    const latRange = maxLat - minLat;
    const lonRange = maxLon - minLon;
    
    // ê°€ë¡œ í­ ê¸°ì¤€ìœ¼ë¡œ ë¹„ìœ¨ì„ ë§ì¶”ë˜, ì„¸ë¡œê°€ ë„ˆë¬´ ì§§ì•„ì§€ì§€ ì•Šê²Œ ì¡°ì •
    const wRatio = canvas.width / lonRange;
    const hRatio = canvas.height / latRange;
    // ë‘ ë¹„ìœ¨ ì¤‘ ì‘ì€ ê°’ì„ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì˜ì—­ì´ ë³´ì´ë„ë¡ í•©ë‹ˆë‹¤.
    const ratio = Math.min(wRatio, hRatio) * 0.8; // 80%ë§Œ ì‚¬ìš©í•´ì„œ íŒ¨ë”© íš¨ê³¼ë¥¼ ì¤Œ
    const pad = 60;

    // ìœ„ê²½ë„ -> ìº”ë²„ìŠ¤ ì¢Œí‘œ ë³€í™˜ í•¨ìˆ˜ (ìˆ˜ì •ë¨)
const latLonToCanvas = (lat, lon) => {
    // [ìˆ˜ì • 1] ê°€ë¡œ/ì„¸ë¡œ ë¹„ìœ¨ì„ ê°ê° ë”°ë¡œ ê³„ì‚° (ì§€ë„ê°€ ì°Œê·¸ëŸ¬ì§€ì§€ ì•Šê²Œ í•¨)
    // ìº”ë²„ìŠ¤ í¬ê¸°(ë˜ëŠ” ì§€ë„ ì´ë¯¸ì§€ í¬ê¸°)ë¥¼ ì „ì²´ ê²½ë„/ìœ„ë„ ë²”ìœ„ë¡œ ë‚˜ëˆ•ë‹ˆë‹¤.
    const totalLon = maxLon - minLon;
    const totalLat = maxLat - minLat;
    
    const ratioX = canvas.width / totalLon;
    const ratioY = canvas.height / totalLat;

    // [ìˆ˜ì • 2] ì¤‘ì‹¬ì (centerX) ê¸°ì¤€ì´ ì•„ë‹ˆë¼, ì™¼ìª½ ìœ„(minLon, maxLat)ë¥¼ 0,0ìœ¼ë¡œ ì¡ê³  ê³„ì‚°
    // ì´ë ‡ê²Œ í•´ì•¼ ê³„ì‚°ì´ í›¨ì”¬ ì§ê´€ì ì´ê³  ì •í™•í•©ë‹ˆë‹¤.
    
    // x: ì™¼ìª½(minLon)ì—ì„œ ì–¼ë§ˆë‚˜ ë–¨ì–´ì¡Œë‚˜?
    let x = (lon - minLon) * ratioX;
    
    // y: ìœ„ìª½(maxLat)ì—ì„œ ì–¼ë§ˆë‚˜ ë–¨ì–´ì¡Œë‚˜? (ìœ„ë„ëŠ” ìœ„ë¡œ ê°ˆìˆ˜ë¡ ê°’ì´ ì»¤ì§€ë¯€ë¡œ ëº„ì…ˆ ìˆœì„œ ì£¼ì˜)
    let y = (maxLat - lat) * ratioY; 

    // [ìˆ˜ì • 3] ì¤Œ/íŒ¬ ë¡œì§ì„ ìœ„í•´ ì¢Œí‘œê³„ ì¤‘ì‹¬ì„ ìº”ë²„ìŠ¤ ì¤‘ì•™ìœ¼ë¡œ ë§ì¶¤
    // ìœ„ì—ì„œ êµ¬í•œ x,yëŠ” 0,0 ê¸°ì¤€ì´ë¯€ë¡œ, ìº”ë²„ìŠ¤ ì ˆë°˜ë§Œí¼ ë¹¼ì„œ ì¤‘ì•™ ê¸°ì¤€ìœ¼ë¡œ ë§Œë“¦
    x -= canvas.width / 2;
    y -= canvas.height / 2;
    
    // [ê¸°ì¡´ ì½”ë“œ ìœ ì§€] ì¤Œ/íŒ¬ ë³€í™˜ ì ìš©
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    // ì¤‘ì•™ì (cx, cy) ê¸°ì¤€ìœ¼ë¡œ ìŠ¤ì¼€ì¼ í™•ëŒ€/ì¶•ì†Œ + ì´ë™(tx, ty)
    x = cx + x * scale + tx;
    y = cy + y * scale + ty;
    
    return {x, y};
};

    // 1. ëª¨ë“  ì—°ê²°ì„  (íšŒìƒ‰ ì„ )
    ctx.strokeStyle = "#e5e7eb"; ctx.lineWidth = 4 * scale;
    EDGES_DATA.forEach(e => { // EDGES_DATAë¥¼ ì‚¬ìš©í•˜ì—¬ ì¤‘ë³µ ì—†ì´ ê·¸ë¦¬ê¸°
        const p1 = latLonToCanvas(AREAS[e.u].lat, AREAS[e.u].lon);
        const p2 = latLonToCanvas(AREAS[e.v].lat, AREAS[e.v].lon);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
    });

    // 2. ê²½ë¡œ (ë¹¨ê°„ ì„ )
    if (route) {
        ctx.strokeStyle = "#ef4444"; 
        ctx.lineWidth = 8 * scale;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        route.path.forEach((id,i) => {
            const p = latLonToCanvas(AREAS[id].lat, AREAS[id].lon);
            if (i===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();
        ctx.lineCap = 'butt';
    }

    // 3. ë…¸ë“œ
    Object.entries(AREAS).forEach(([id, a]) => {
        const {x, y} = latLonToCanvas(a.lat, a.lon);
        
        // í˜„ì¬ ì´ë™ ì¤‘ì¸ ë…¸ë“œ ê°•ì¡°
        let isCurrentNode = false;
        if (route && route.currentStep < route.steps.length) {
            const currentStep = route.steps[route.currentStep];
            if (id === currentStep.to || id === route.path[0]) { // ì¶œë°œ ë…¸ë“œë„ ê°•ì¡°
                isCurrentNode = true;
            }
        }
        
        ctx.fillStyle = isCurrentNode ? "#22c55e" : (route && route.path.includes(id) ? "#3b82f6" : "#94a3b8");
        ctx.beginPath(); ctx.arc(x,y,12 * scale,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle = "white"; ctx.lineWidth = 3 * scale; ctx.stroke();
        
        ctx.fillStyle = "white"; ctx.font = `bold ${14 * scale}px sans-serif`; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(id, x, y);
        
        ctx.fillStyle = "#333"; ctx.font = `${10 * scale}px sans-serif`; 
        ctx.fillText(a.name.split(' ')[0], x, y + 18 * scale);
    });

// 4. ì‚¬ìš©ì ìœ„ì¹˜ (ë…¸ë€ ì )
if (userPos) {
    const {x, y} = latLonToCanvas(userPos.lat, userPos.lon);
    
    // 1. í•„í„°ë§: RAW ê°’ì´ ìœ íš¨í•  ë•Œë§Œ smoothedHeadingì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    if (userPos.heading !== null && userPos.heading !== undefined) {
        // RAW ê°’ì´ ìœ íš¨í•  ë•Œë§Œ ë¶€ë“œëŸ¬ìš´ ê°’ì— ì €ì¥
        smoothedHeading = applyFilter(userPos.heading, smoothedHeading);
    }
    
    // 2. ê·¸ë¦¬ê¸°: ë„¤ë¹„ê²Œì´ì…˜ì´ ì¼œì ¸ ìˆê±°ë‚˜, ìµœì†Œí•œ í•œ ë²ˆì´ë¼ë„ ë°©í–¥ ê°’ì´ ë“¤ì–´ì™”ë‹¤ë©´ (smoothedHeadingì´ 0ì´ ì•„ë‹ˆë©´) ê·¸ë¦½ë‹ˆë‹¤.
    if (watching || smoothedHeading !== 0) { 
        
        const headingToDraw = smoothedHeading; 
        
        const fov = 60; 
        const radius = 60 * scale; 
        
        // ê°ë„ ë³€í™˜
        const startAngle = (headingToDraw - (fov / 2) - 90) * (Math.PI / 180);
        const endAngle = (headingToDraw + (fov / 2) - 90) * (Math.PI / 180);

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.arc(x, y, radius, startAngle, endAngle);
        ctx.lineTo(x, y);
        
        // ğŸš¨ í…ŒìŠ¤íŠ¸ìš©: í•„í„°ê°€ ì ìš©ëœ ë¶€ì±„ê¼´
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)"; 
        
        ctx.fill();
        ctx.restore();
    }
    
    // ë…¸ë€ ì  (ì‚¬ìš©ì)
    ctx.fillStyle = "#facc15";
    ctx.beginPath(); ctx.arc(x,y,14 * scale,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = "white"; ctx.lineWidth = 4 * scale; ctx.stroke();
}
}
// í„°ì¹˜/ë§ˆìš°ìŠ¤ ì¤Œ & íŒ¬
function setupCanvasEvents() {
    let dragging = false, lastX, lastY, initialScale = 1;
    let st = []; // For touch points
    let touchDist = 0; // For pinch zoom distance

    // Mouse events
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        // ì¤Œ ì¤‘ì‹¬ì ì„ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¡œ ì„¤ì •í•˜ë ¤ë©´ ë” ë³µì¡í•œ ë¡œì§ì´ í•„ìš”í•˜ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœ ì¤‘ì•™ ì¤Œì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
        scale = Math.max(0.5, Math.min(5, scale * (e.deltaY < 0 ? 1.1 : 0.9)));
        draw();
    }, { passive: false });

    canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    canvas.addEventListener('mousemove', e => {
        if (dragging) {
            tx += e.clientX - lastX; ty += e.clientY - lastY;
            lastX = e.clientX; lastY = e.clientY;
            draw();
        }
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);

    // Touch events
    canvas.addEventListener('touchstart', e => { 
        e.preventDefault(); 
        st = Array.from(e.touches);
        if (st.length === 1) {
            dragging = true; lastX = st[0].clientX; lastY = st[0].clientY;
        } else if (st.length === 2) {
            initialScale = scale;
            touchDist = Math.hypot(st[0].clientX - st[1].clientX, st[0].clientY - st[1].clientY);
            dragging = false; // ë‘ ì†ê°€ë½ í„°ì¹˜ ì‹œ íŒ¬ ê¸°ëŠ¥ì€ ì •ì§€
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        e.preventDefault(); 
        const t = Array.from(e.touches);
        if (t.length === 1 && dragging) { 
            tx += t[0].clientX - lastX; ty += t[0].clientY - lastY; 
            lastX = t[0].clientX; lastY = t[0].clientY; 
        } else if (t.length === 2 && st.length === 2) {
            const newDist = Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
            if (touchDist > 0) {
                scale = Math.max(0.5, Math.min(5, initialScale * (newDist / touchDist)));
            }
        }
        draw();
    }, { passive: false });

    canvas.addEventListener('touchend', () => { 
        dragging = false; 
        st = [];
        // ë‚´ë¹„ê²Œì´ì…˜ ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³µêµ¬ ë¡œì§ (ì¤Œ/íŒ¬ í›„ ìƒíƒœ ë³µì›)
        if (route && route.currentStep >= route.steps.length) { 
             document.getElementById('nav-btn').textContent = "ì¬ì„¤ì •";
             document.getElementById('nav-btn').classList.replace('bg-yellow-500','bg-blue-600');
        } else if (watching) {
            document.getElementById('nav-btn').textContent = "ì •ì§€";
            document.getElementById('nav-btn').classList.replace('bg-yellow-500','bg-red-500');
        } else if(route) {
            document.getElementById('nav-btn').textContent = "ì¬ê°œ";
            document.getElementById('nav-btn').classList.replace('bg-red-500','bg-yellow-500');
        }
    });


}
</script>
</body>
</html>
